package com.example.designPattern.state;

/**
 * 《状态模式》
 *      当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。
 *
 *  角色介绍：
 *      1、抽象状态角色（State）：接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。
 *
 *      2、具体状态角色（ConcreteState）：每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态处理，通俗地说，就是本状态下要做的事情，以及本状态如何过渡到其他状态。
 *
 *      3、环境角色（Context）：定义客户端需要的接口，并且负责具体状态的切换。
 *
 *  这种结构看起来类似于“策略”模式，但有一个关键的区别。在状态模式中，特定状态可能彼此了解，并开始从一个状态过渡到另一个状态，而策略几乎永远不会彼此了解。
 *
 *  优点：
 *      1、符合单一职责原则：将与特定状态相关的代码组织到单独的类中。
 *      2、符合开放封闭原则：在不更改现有状态类或上下文的情况下引入新状态。
 *
 *  缺点：
 *      1、如果有很多种状态，子类会太多，类膨胀。一个事物有很多个状态也不稀奇，如果完全使用状态模式就会有太多的子类，不好管理。
 *      2、如果类只有几个状态或很少更改，应用状态模式可能会过度设计。
 *
 * @author yupan
 * @date 7/5/21 9:55 PM
 */
public class StateTest {

    public static void main(String[] args) {
        // 台灯默认关闭
        Lamp lamp = new Lamp();
        // 正常光
        lamp.click();
        // 强光
        lamp.click();
        // 弱光
        lamp.click();
        // 关闭
        lamp.click();
        // 正常光
        lamp.click();
    }
}
